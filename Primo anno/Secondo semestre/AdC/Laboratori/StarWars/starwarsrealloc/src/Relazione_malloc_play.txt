Il programma malloc_play consiste nel testing dell'organizzazione della memoria (heap) nella macchina corrente. 
In un primo momento stabilisce i valori base di sz, max e min, che consistono negli indici utilizzati nel ridimensionamento dei puntatori (sz) e nella stampa dell'array (max e min). In particolare sz indica il numero di byte che si vogliono man mano riservare al puntatore, che nel nostro caso corrispondono ai caratteri in più da leggere e stampare, in quanto 1 char = 1 byte per convezione.
Lasciando i valori di default abbiamo sz = 1, min = -16, max = 60.
Il programma comincia allocando una dimensione pari a sz di memoria, facendola puntare da un puntatore denominato p. Al contenuto puntato da tale puntatore viene inizialmente assegnato il carattere 'p'. Dopodiché si procede alla stampa di p. E' possibile sin da subito notare che per definizione, quando viene allocata una nuova cella di memoria, essa si trova presso p[0]: viene stampata la codifica numerica ASCII del carattere 'p'; dunque ogni altro accesso da p[-16] a p[60] risulta nella stampa di valori non propri a p (una specie di overflow, vado oltre la zona riservata), alcuni di questi assumono valore zero, indice del fatto che le celle non sono allocate (in via generale, alcuni di questi potrebbero essere il valore intero zero), mentre alcune celle sono occupate da numeri il cui significato non è noto al programma corrente (sono le interazioni di altri programmi con la memoria).
In seguito viene creato un puntatore q, il cui contenuto puntato è inizialmente il carattere 'q'. Tale puntatore viene stampato con un indice di min triplicato (-16*3 = -48).
in seguito a ulteriori stampe il programma procede con la creazione di un puntatore oldp puntante le stesse celle di p e il ridimensionamento di p con la funzione realloc(), con una quantità di byte maggiore, tale da poter immagazzinare l'input successivo. Viene infatti sovrascritto il contenuto precedente puntato da p con la stringa "startp", in cui singoli caratteri sono codificati in forma numerica da p[0] nella stampa.
In seguito all'aggiunta di nuovo spazio per p con realloc() e l'inserimento della nuova stringa "modifiedp", si procede con la stampa di p e oldp. Sia nel caso precedente che in questo può succedere di osservare un caso bizzarro: oldp punta alle stesse celle di p ma può capitare di osservare valori diversi assunti da oldp e p in fase di stampa. Questo perchè può succedere che i due puntatori vengono stampati in momenti diversi del programma, quindi alcuni valori (non propri a p) sono modificati da altri programmi che interagiscono con la memoria; inoltre visto il continuo ridimensionamento dell'array p (con la creazione continua di nuovi puntatori p), può succedere che oldp non riesca a seguire le effettive celle a cui puntava p, in quanto spesso realloc(), non riuscendo ad allocare celle contigue nella memoria, sposta l'intera porzione di memoria riservata a p in un punto tale da poter effettuare il ridimensionamento. Tale azione può non essere facilmente seguita da olpd, ancora puntante alle celle precedenti.
Infine il programma procede con la deallocazione della memoria riservata a p e q: è possibile vedere come il contenuto delle celle riservate assume valore zero; alcune contengono ancora dei valori, il motivo è da ricondursi alla "confusione" dei ridimensionamenti citata sopra.
Un fatto importante è la chiamata di "free((void*)oldp);", in quanto se de-commento tale azione, la compilazione ritorna un errore, dato dal fatto che comunque idealmente oldp punta alle celle di p, nonostante i ridimensionamenti, quindi attuando una free() di p, automaticamente sto rimuovendo le celle a cui punta anche oldp: una nuova chiamata di free() su oldp risulterebbe in una doppia chiamata free sullo stesso puntatore nonché nell'accesso illecito a celle non allocate.
